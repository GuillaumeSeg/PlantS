package openGL3;

import java.io.File;
import java.nio.FloatBuffer;
import java.util.Iterator;
import java.util.List;

import javax.media.opengl.GL2;
import javax.media.opengl.GL3;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLEventListener;
import javax.vecmath.Vector3f;

import org.jdom2.Element;

import utils.CST;

import com.jogamp.common.nio.Buffers;

public class JOGLRenderer implements GLEventListener {
	
	ShaderProgram m_ShaderProgram;
	JDOMHierarchy m_TreeHierarchy;
	
	int m_NbVertices;
	FloatBuffer m_VerticesPosition;
	FloatBuffer m_VerticesColor;
	FloatBuffer m_VerticesRepere;
	
	MatrixStack m_MatrixStack;
	int m_MVPLocation;
	
	float angle;
	
	public void display(GLAutoDrawable drawable) {
		
		GL3 gl = drawable.getGL().getGL3();
		gl.glClearColor(0.f, 0.f, 0.f, 1.0f);
        gl.glClear(GL3.GL_STENCIL_BUFFER_BIT | GL3.GL_COLOR_BUFFER_BIT | GL3.GL_DEPTH_BUFFER_BIT );
        gl.glUseProgram(m_ShaderProgram.getProgram());
        
        drawRepere(gl);
        
        
        
        
	}

	public void dispose(GLAutoDrawable drawable) {

	}

	public void init(GLAutoDrawable drawable) {
		
		GL3 gl = drawable.getGL().getGL3();
		m_ShaderProgram = new ShaderProgram(drawable, new File("src/shaders/color.vs.glsl"), new File("src/shaders/color.fs.glsl"));
		
		m_TreeHierarchy = new JDOMHierarchy(new File("src/xml/xml_tree.xml"));

		
		m_NbVertices = 4;
		
		float[] verticesPosition = new float[] { 
        		-0.5f, 0.5f, -0.0f,
        		0.5f, 0.5f, -0.0f,
        		0.5f, -0.5f, -0.0f,
        		-0.5f, -0.5f, -0.0f
         };		
		m_VerticesPosition = Buffers.newDirectFloatBuffer(verticesPosition);
		
		float[] verticesRepere = new float[] { 
        		0f, 0f, 0f,
        		1f, 0f, 0f,
        		0f, 0f, 0f,
        		0f, 1f, 0f,
        		0f, 0f, 0f,
        		0f, 0f, 1f
         };		
		m_VerticesRepere = Buffers.newDirectFloatBuffer(verticesRepere);
		
		float[] verticesColor = new float[] {
				0.2f, 0.2f, 0.2f,
				0.7f, 0.7f, 0.7f,
				0.5f, 0.5f, 0.5f,
				0.2f, 0.2f, 0.2f
		};
		m_VerticesColor = Buffers.newDirectFloatBuffer(verticesColor);
		
		m_MatrixStack = new MatrixStack();
		
		m_MVPLocation = gl.glGetUniformLocation(m_ShaderProgram.getProgram(), "uniform_MVP");
		
		angle = 0;
		
	}

	public void reshape(GLAutoDrawable drawable, int arg1, int arg2, int arg3, int arg4) {

	}

	public void drawRepere(GL3 gl){
		
		gl.glEnableVertexAttribArray(CST.SHADER_POSITION_LOCATION);        
        gl.glVertexAttribPointer(CST.SHADER_POSITION_LOCATION, 3, GL3.GL_FLOAT, false, 0, m_VerticesRepere);
        
        gl.glEnableVertexAttribArray(CST.SHADER_COLOR_LOCATION);        
        gl.glVertexAttribPointer(CST.SHADER_COLOR_LOCATION, 3, GL3.GL_FLOAT, false, 0, m_VerticesRepere);
        
        gl.glUniformMatrix4fv(m_MVPLocation, 1, false, m_MatrixStack.parseTopToFloatArray(), 0);
        gl.glDrawArrays(GL3.GL_LINES, 0, 6);
	}
	
	public void drawJDOM(Element element, GL2 gl){

		draw(element, gl);
		
		if(element.getName() == "trunck"){
			gl.glPushMatrix();
			String axeXYZ = element.getAttributeValue("axe"); //On récupère l'attribut du trunck actuel
			String vect[] = axeXYZ.split(" "); // On sépare nos axes avec split()
			float x = Float.parseFloat(vect[0]); // On stocke nos axes (x,y,z)
			float y = Float.parseFloat(vect[1]);
			float z = Float.parseFloat(vect[2]);
				gl.glRotatef(Float.parseFloat(element.getAttributeValue("angle")), x, y, z);
				gl.glTranslatef(0.0f, Float.parseFloat(element.getAttributeValue("height")), 0.0f);
				
				if(!element.getChildren().isEmpty()){
					List<Element> childrenList = element.getChildren();
					Iterator itChildren = childrenList.iterator();
					while(itChildren.hasNext()){
						Element child = (Element)itChildren.next();
						drawJDOM(child, gl);
					}
					
				}
				gl.glPopMatrix();
		}else{
			if(!element.getChildren().isEmpty()){
				List childrenList = element.getChildren();
				Iterator itChildren = childrenList.iterator();
				while(itChildren.hasNext()){
					Element child = (Element)itChildren.next();
					drawJDOM(child, gl);
				}
			}
		}
		
	}

	public void draw(Element element, GL2 gl){

		if(element.getName() == "trunck"){
			
			// read element attributes
			float height = Float.parseFloat(element.getAttributeValue("height"));
			float angle = Float.parseFloat(element.getAttributeValue("angle"));
			String axeXYZ = element.getAttributeValue("axe");
			String vect[] = axeXYZ.split(" ");
			float x = Float.parseFloat(vect[0]);
			float y = Float.parseFloat(vect[1]);
			float z = Float.parseFloat(vect[2]);
			
			m_MatrixStack.push();
				m_MatrixStack.rotate(new Vector3f(x, y, z), angle);
				m_MatrixStack.scale(1);
				drawPrimitiveTrunk(gl);
			m_MatrixStack.pop();

		}
		
		if(element.getName() == "leaf"){
			
			// read element attributes
			float size = Float.parseFloat(element.getAttributeValue("size"));
			m_MatrixStack.push();
				m_MatrixStack.translate(new Vector3f(0, size/2, 0));
				m_MatrixStack.rotate(new Vector3f(0f, 0f, 1f), 45);
				m_MatrixStack.scale(1);
			m_MatrixStack.pop();
				gl.glTranslatef(0, size/2, 0);
				gl.glRotatef(45, 0, 0, 1);		
				gl.glScalef(size, size, 1);
				drawPrimitiveLeaf(gl);
			gl.glPopMatrix();
		}
	}
	
	private static void drawPrimitiveTrunk(GL2 gl){
		gl.glColor3f(255.0f, 255.0f, 255.0f);
		gl.glBegin(GL2.GL_LINES);
			gl.glVertex3f(0.0f, 0.0f, 0.0f);
			gl.glVertex3f(0.0f, 1.0f, 0.0f);
		gl.glEnd();
	}
	
	
	
}
