import java.io.File;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;

import javax.media.opengl.GL2;
import javax.media.opengl.GL3;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.glu.GLU;

import utils.CST;

public class JOGLRenderer implements GLEventListener {
	
	private ShaderProgram m_ShaderProgram;
	
	public void init(GLAutoDrawable drawable) {
		
		// Setup opengl
        GL3 gl = drawable.getGL().getGL3();       
        gl.glClearColor(0.0f, 0.2f, 0.2f, 0.0f);        
        gl.glClearDepth(1.0f);          
        gl.glEnable(GL3.GL_DEPTH_TEST);         
        gl.glDepthFunc(GL3.GL_LEQUAL);           
        gl.glHint(GL2.GL_PERSPECTIVE_CORRECTION_HINT, GL3.GL_NICEST);
        
        // Create vertex data         
        float[] vertices = new float[]{
              0.5f, 0.5f 
        };
        ByteBuffer vertexByteBuffer = ByteBuffer.allocateDirect(vertices.length*CST.SIZEOF_FLOAT);            
        vertexByteBuffer.order(ByteOrder.nativeOrder());      
        FloatBuffer vertexBuffer = vertexByteBuffer.asFloatBuffer();          
        vertexBuffer.put(vertices);
        
        // Create vbo        
        int[] vbo = new int[1];         
        gl.glGenBuffers(1, vbo, 0);        
        	gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, vbo[0]);      
        gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices.length*CST.SIZEOF_FLOAT, null, GL2.GL_DYNAMIC_DRAW); 
        // Load vertex data into vertex buffer         
        gl.glBufferSubData(GL2.GL_ARRAY_BUFFER, 0, vertexByteBuffer.capacity(), vertexByteBuffer);
        
        // Create vao
        int[] vao = new int[1];
        gl.glGenVertexArrays(1, vao, 0);
        gl.glBindVertexArray(vao[0]);
        	gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, vbo[0]);
        	gl.glEnableVertexAttribArray(CST.SHADER_POSITION_LOCATION);
        	
        	gl.glVertexAttribPointer(
        			CST.SHADER_POSITION_LOCATION, // attribute location into shader
        			2, // number of element for the attribute
        			GL2.GL_FLOAT, // data type
        			GL2.GL_FALSE, // normalize ?
        			2*CST.SIZEOF_FLOAT, // 1 vertex total size
        			0 // attribute offset      			
        	);
        	
        	gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, 0);
        gl.glBindVertexArray(0);
        
        
        m_ShaderProgram = new ShaderProgram(drawable, new File("src/shaders/color.vs.glsl"), new File("src/shaders/color.fs.glsl"));
	}
	
	public void display(GLAutoDrawable drawable) {
		
		GL3 gl = drawable.getGL().getGL3();   
        gl.glClear(GL3.GL_COLOR_BUFFER_BIT | GL3.GL_DEPTH_BUFFER_BIT);
		System.out.println("GL Error(s) : " + gl.glGetError());
		
		gl.glVertexAttribPointer(
				CST.SHADER_POSITION_LOCATION, // index of attribute into shader
				3, // number of float for 1 vertex
				gl.GL_FLOAT, // datatype
				false, // normalize ?
				3*CST.SIZEOF_FLOAT, // One vertex total size
				0 // attribute's offset
		);
		
		// shader code
		gl.glUseProgram(m_ShaderProgram.p);
			//start render at 0 vertex go to 3 for a count of 4
			gl.glDrawRangeElements(GL2.GL_TRIANGLE_STRIP, 0, 3, 4, GL2.GL_UNSIGNED_INT, 0);		
		gl.glUseProgram(0);
		
	}

	public void dispose(GLAutoDrawable drawable) {
	
	}

	public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) {
		GL3 gl = drawable.getGL().getGL3();     
        GLU glu = new GLU(); 
        gl.glViewport(0, 0, width, height);   
        glu.gluPerspective(45.0f, (float) width / (float) height, 0.1f, 100.0f);
	}
	
	
}
